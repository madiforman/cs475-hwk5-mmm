#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"
#include "rtclock.h"
#define MIN 0
#define MAX 99
/**
 * @brief Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random doubles from 0 to 99
 *
 * @return double** allocated matrix with random doubles
 */
double **mmm_init()
{
	double **matrix = (double **)malloc(SIZE * sizeof(double *));
	for (int i = 0; i < SIZE; i++)
	{
		matrix[i] = (double *)malloc(SIZE * sizeof(double));
	}
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			matrix[i][j] = rand() % 100;
		}
	}
	return matrix;
}
/**
 * @brief Resets a given matrix to zeros
 *
 * @param matrix matrix to be reset
 */
void mmm_reset(double **matrix)
{

	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			matrix[i][j] = 0;
		}
	}
}

/**
 * @brief Free up memory allocated to all matrices
 *
 * @param mode either char 'S' or 'P' for parallel or sequential
 */
void mmm_freeup(char mode)
{
	free(MA);
	free(MB);
	free(MC);
	if (mode == 'P')
	{
		free(verify_c); /*if parallel free verify matrix*/
	}
}

/**
 * Sequential MMM
 */
double mmm_seq(double **matrix)
{
	double start = rtclock();
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			for (int k = 0; k < SIZE; k++)
			{
				matrix[i][j] += MA[i][k] * MB[k][j];
			}
		}
	}
	double end = rtclock();
	return end - start;
}
/**
 * @brief Creates a blank matrix
 *
 * @return double** blank matrix
 */
double **create_matrix()
{
	double **matrix = (double **)malloc(SIZE * sizeof(double *));
	for (int i = 0; i < SIZE; i++)
	{
		matrix[i] = (double *)malloc(SIZE * sizeof(double));
	}
	return matrix;
}
/**
 * Parallel MMM
 */
void *mmm_par(void *args)
{
	thread_args *t_args = (thread_args *)args;
	for (int i = t_args->start; i < t_args->end; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			for (int k = 0; k < SIZE; k++)
			{
				MC[i][j] += MA[i][k] * MB[k][j];
			}
		}
	}
	return NULL;
}
/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 */
double mmm_verify()
{
	double max_err = 0;
	for (int i = 0; i < SIZE; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			double dif = MC[i][j] - verify_c[i][j];
			if (dif > max_err)
			{
				max_err = dif;
			}
		}
	}

	return max_err;
}
