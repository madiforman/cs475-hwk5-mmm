#include <stdlib.h>
#include <time.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include "mmm.h"
#include "rtclock.h"
#define MIN 0
#define MAX 99
/**
 * Allocate and initialize the matrices on the heap. Populate
 * the input matrices with random integers from 0 to 99
 */
double **mmm_init(int size)
{
	double **matrix = (double **)malloc(size * sizeof(double *));
	for (int i = 0; i < size; i++)
	{
		// printf("here\n");
		matrix[i] = (double *)malloc(size * sizeof(double));
	}
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			matrix[i][j] = rand() % 100;
			printf("%lf\t", matrix[i][j]);
		}
		printf("\n");
	}
	return matrix;
}
/**
 * Reset a given matrix to zeroes
 */
double **mmm_reset(int size)
{
	double **matrix = (double **)malloc(size * sizeof(double *));
	for (int i = 0; i < size; i++)
	{
		matrix[i] = (double *)malloc(size * sizeof(double));
	}
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			matrix[i][j] = 0;
			printf("%lf\t", matrix[i][j]);
		}
		printf("\n");
	}
	return matrix;
}

/**
 * Free up memory allocated to all matrices
 */
void mmm_freeup()
{
	// TODO
}

/**
 * Sequential MMM
 */
double mmm_seq(double **MA, double **MB, double **MC, int size)
{
	double start = rtclock();
	for (int i = 0; i < size; i++)
	{
		for (int j = 0; j < size; j++)
		{
			MC[i][j] = 0;
			for (int k = 0; k < size; k++)
			{
				MC[i][j] += MA[i][k] * MB[k][j];
			}
		}
	}
	double end = rtclock();
	return end - start;
}
double **create_matrix()
{
	double **matrix = (double **)malloc(SIZE * sizeof(double *));
	for (int i = 0; i < SIZE; i++)
	{
		matrix[i] = (double *)malloc(SIZE * sizeof(double));
	}
	return matrix;
}
void *mmm_par(void *args)
{
	thread_args *data = args;
	int i = 0;
	for (i = data->i; i < data->j; i++)
	{
		for (int j = 0; j < SIZE; j++)
		{
			// double result = 0;
			for (int k = 0; k < SIZE; k++)
			{
				mtrx_c[i][j] += mtrx_a[i][k] * mtrx_b[k][j];
			}
			printf("%lf\n", mtrx_c[i][j]);
		}
	}
	return NULL;
}
/**
 * Parallel MMM
 */
// void *mmm_par(void *args)
// {
// 	double result, portion, start, end;

// 	int tid = *(int *)(args);
// 	portion = SIZE / t_num;
// 	start = tid * portion;
// 	end = (tid + 1) * portion;

// 	for (int i = start; i < end; i++)
// 	{
// 		for (int j = 0; j < SIZE; j++)
// 		{
// 			result = 0;
// 			for (int k = 0; k < SIZE; k++)
// 			{
// 				result += mtrx_a[i][k] * mtrx_b[k][j];
// 			}
// 			mtrx_c[i][j] = result;
// 		}
// 	}
// }
void test()
{
	printf("%d\n", SIZE);
}
/**
 * Verifies the correctness between the matrices generated by
 * the sequential run and the parallel run.
 *
 * @return the largest error between two corresponding elements
 */
double mmm_verify()
{
	// TODO
	return -1;
}

void print_boilerplate(char mode, double time, int size)
{
	if (mode == 'S')
	{
		printf("========\n");
		printf("mode: sequential\n");
		printf("thread count: 1\n");
		printf("size: %d\n", size);
		printf("========\n");
		printf("Sequential Time: %f\n", time);
	}
}